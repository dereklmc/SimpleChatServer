import java.io.Serializable;
import java.util.Arrays;

/**
 * Represents messages sent between nodes in a server-less chat network.
 * 
 * Messages can be sent directly as objects, keeping intact their original sent
 * state, allowing destination nodes to deliver messages in a causal order.
 * 
 * @author Derek McLean
 * 
 */
public class Message implements Serializable {

	// autogenerated, for serializing message
	private static final long serialVersionUID = -1071983615436769006L;

	// The vector time clock for this message
	private int state[] = null;
	// The textual body of the message, to be printed out
	private String body = null;
	// The rank of the host sending this message. Storing this makes code
	// cleaner.
	private int hostRank = -1;

	/**
	 * Instantiates a new message being sent by a given host, with a given
	 * timestamp and text body.
	 * 
	 * @param hostRank
	 *            - the rank of the host sending the message
	 * @param state
	 *            - the vector timestamp for the message
	 * @param body
	 *            - the actual message for the destination to 'deliver' - print
	 *            out.
	 */
	public Message(int hostRank, int[] state, String body) {
		this.hostRank = hostRank;
		this.state = Arrays.copyOf(state, state.length);
		this.body = body;
	}

	/**
	 * For printing/delivering the message. Returns the contents of the message.
	 */
	@Override
	public String toString() {
		return body;
	}

	/**
	 * @return the rank of the host sending the given message.
	 */
	public int getHost() {
		return hostRank;
	}

	/**
	 * Checks if a message is deliverable.
	 * 
	 * Follows rules for causally ordering messages: a message is not
	 * deliverable until it is next in the causal chain.
	 * 
	 * @param recieverState
	 *            - The timestamp of the receiver of the current message.
	 * @return true if the message is causally next, i.e. can be delivered.
	 *         Otherwise, false.
	 */
	public boolean isDeliverable(int[] recieverState) {
		if (state[hostRank] != recieverState[hostRank] + 1) {
			return false;
		}
		for (int j = 0; j < state.length; j++) {
			if (j != hostRank && state[j] > recieverState[j]) {
				return false;
			}
		}
		return true;
	}

}
